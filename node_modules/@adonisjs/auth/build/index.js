import {
  AuthManager,
  Authenticator,
  AuthenticatorClient
} from "./chunk-OL2Z3AO5.js";
import "./chunk-3HZHOWKL.js";
import {
  E_INVALID_CREDENTIALS,
  errors_exports
} from "./chunk-UGHJLKDI.js";
import {
  __decorateClass,
  __export
} from "./chunk-CZCFTIBB.js";

// configure.ts
import { presetAuth } from "@adonisjs/presets/auth";
async function configure(command) {
  const codemods = await command.createCodemods();
  let guard = command.parsedFlags.guard;
  if (guard === void 0) {
    guard = await command.prompt.choice(
      "Select the auth guard you want to use",
      [
        {
          name: "session",
          message: "Session"
        },
        {
          name: "access_tokens",
          message: "Opaque access tokens"
        }
      ],
      {
        validate(value) {
          return !!value;
        }
      }
    );
  }
  if (!["session", "access_tokens"].includes(guard)) {
    command.logger.error(
      `The selected guard "${guard}" is invalid. Select one from: session, access_tokens`
    );
    command.exitCode = 1;
    return;
  }
  await presetAuth(codemods, command.app, {
    guard,
    userProvider: "lucid"
  });
}

// src/symbols.ts
var symbols_exports = {};
__export(symbols_exports, {
  GUARD_KNOWN_EVENTS: () => GUARD_KNOWN_EVENTS,
  PROVIDER_REAL_USER: () => PROVIDER_REAL_USER
});
var PROVIDER_REAL_USER = Symbol.for("PROVIDER_REAL_USER");
var GUARD_KNOWN_EVENTS = Symbol.for("GUARD_KNOWN_EVENTS");

// src/define_config.ts
import { configProvider } from "@adonisjs/core";
function defineConfig(config) {
  return configProvider.create(async (app) => {
    const guardsList = Object.keys(config.guards);
    const guards = {};
    for (let guardName of guardsList) {
      const guard = config.guards[guardName];
      if (typeof guard === "function") {
        guards[guardName] = guard;
      } else {
        guards[guardName] = await guard.resolver(guardName, app);
      }
    }
    return {
      default: config.default,
      guards
    };
  });
}

// src/mixins/with_auth_finder.ts
import { RuntimeException } from "@adonisjs/core/exceptions";
import { beforeSave } from "@adonisjs/lucid/orm";
function withAuthFinder(hash, options) {
  return (superclass) => {
    class UserWithUserFinder extends superclass {
      static async hashPassword(user) {
        if (user.$dirty[options.passwordColumnName]) {
          ;
          user[options.passwordColumnName] = await hash().make(
            user[options.passwordColumnName]
          );
        }
      }
      /**
       * Finds the user for authentication via "verifyCredentials".
       * Feel free to override this method customize the user
       * lookup behavior.
       */
      static findForAuth(uids, value) {
        const query = this.query();
        uids.forEach((uid) => query.orWhere(uid, value));
        return query.limit(1).first();
      }
      /**
       * Find a user by uid and verify their password. This method is
       * safe from timing attacks.
       */
      static async verifyCredentials(uid, password) {
        if (!uid || !password) {
          throw new E_INVALID_CREDENTIALS("Invalid user credentials");
        }
        const user = await this.findForAuth(options.uids, uid);
        if (!user) {
          await hash().make(password);
          throw new E_INVALID_CREDENTIALS("Invalid user credentials");
        }
        const passwordHash = user[options.passwordColumnName];
        if (!passwordHash) {
          throw new RuntimeException(
            `Cannot verify password during login. The value of column "${options.passwordColumnName}" is undefined or null`
          );
        }
        if (await hash().verify(passwordHash, password)) {
          return user;
        }
        throw new E_INVALID_CREDENTIALS("Invalid user credentials");
      }
    }
    __decorateClass([
      beforeSave()
    ], UserWithUserFinder, "hashPassword", 1);
    return UserWithUserFinder;
  };
}
export {
  AuthManager,
  Authenticator,
  AuthenticatorClient,
  configure,
  defineConfig,
  errors_exports as errors,
  symbols_exports as symbols,
  withAuthFinder
};
//# sourceMappingURL=index.js.map